<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation Page</title>
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <nav id="navbar">
        <header>
          <h1>React.js Docs</h1> 
        </header>
        
          <a href="#Introduction" class="nav-link">Introduction</a> <hr>
          <a href="#Hello_World" class="nav-link">Hello World</a> <hr>
          <a href="#Introducing_JSX" class="nav-link">Introducing JSX</a> <hr>
          <a href="#Rendering_Elements" class="nav-link">Rendering Elements</a> <hr>
          <a href="#Components_and_Props" class="nav-link">Components and Props</a> <hr>
          <a href="#State_and_Lifecycle" class="nav-link">State and Lifecycle</a> <hr>
          <a href="#Handling_Events" class="nav-link">Handling Events</a> <hr>
          <a href="#Conditional_Rendering" class="nav-link">Conditional Rendering</a> <hr>
          <a href="#Lists_and_Keys" class="nav-link">Lists and Keys</a> <hr>
          <a href="#Forms" class="nav-link">Forms</a> <hr>
          <a href="#Lifting_State_Up" class="nav-link">Lifting State Up</a> <hr>
          <a href="#Thinking_React" class="nav-link">Thinking React</a> <hr>
      </nav>
      
      <main id="main-doc">
         <section id="Introduction" class="main-section">
           <header>Introduction</header>
          <p>React is a JavaScript library for building user interfaces. React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.</p>
        </section>
        
        <section id="Hello_World" class="main-section">
          <header>Hello World</header>
          <p>The smallest React example looks like this:</p>
          <code>
            ReactDOM.render(
        <h1>Hello, world!</h1>,
        document.getElementById('root')
      );
          </code>
          <p>It displays a heading saying “Hello, world!” on the page.</p>
        </section>
        
        <section id="Introducing_JSX" class="main-section">
          <header>Introducing JSX</header>
          <p>Consider this variable declaration:</p>
          <code>const element = <h1>Hello, world!</h1>;</code>
          <p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p>
        </section>
        
        <section id="Rendering_Elements" class="main-section">
          <header>Rendering Elements</header>
          <p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
        </section>
        
        <section id="Components_and_Props" class="main-section">
          <header>Components and Props</header>
          <p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p> 
          <p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p>
          <code>
            function Welcome(props) {
        return <h1>Hello, {props.name}</h1>;
      }
          </code>
          <p>You can also use an ES6 class to define a component:</p>
          <code>
            class Welcome extends React.Component {
        render() {
          return <h1>Hello, {this.props.name}</h1>;
        }
      }
          </code>
        </section>
        
        <section id="State_and_Lifecycle" class="main-section">
          <header>State and Lifecycle</header>
          <p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>
          <p>These are the types of Lifecycle methods: </p>
          <ul>
            <li>Mount</li>
            <li>Unount</li>
          </ul>
        </section>
        
        <section id="Handling_Events" class="main-section">
          <header>Handling Events</header>
          <p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:</p>
          <ul>
            <li>React events are named using camelCase, rather than lowercase.</li>
            <li>With JSX you pass a function as the event handler, rather than a string.</li>
          </ul>
          <code>
            button onClick={activateLasers}
        Activate Lasers
      </button>
          </code>
        </section>
        
        <section id="Conditional_Rendering" class="main-section">
          <header>Conditional Rendering</header>
          <p>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.</p>
          <code>
            function Greeting(props) {
        const isLoggedIn = props.isLoggedIn;
        if (isLoggedIn) {
          return <UserGreeting />;
        }
        return <GuestGreeting />;
      }
      
      ReactDOM.render(
        // Try changing to isLoggedIn={true}:
        <Greeting isLoggedIn={false} />,
        document.getElementById('root')
      );
          </code>
        </section>
        
        <section id="Lists_and_Keys" class="main-section">
          <header>Lists and Keys</header>
          <ul>
            <li>Lists :
             Usually you would render lists inside a component.
              <p> We can refactor the previous example into a component that accepts an array of numbers and outputs a list of elements.
                <p><code>
                  function NumberList(props) {
        const numbers = props.numbers;
        const listItems = numbers.map((number) =>
          {number}
        );
        return (
          {listItems}
        );
      }
      
      const numbers = [1, 2, 3, 4, 5];
      <p>ReactDOM.render(
        <NumberList numbers={numbers} />,
        document.getElementById('root')
      );<p>
                  </code></p>
              </p>
            </li>
          <li> Keys: 
            Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:
            <p><code>
              const numbers = [1, 2, 3, 4, 5];
      const listItems = numbers.map((number) =>
        key={number.toString()}
          {number}
      );
              </code></p>
          </li>
          </ul>
        </section>
        
        <section id="Forms" class="main-section">
          <header>Forms</header>
          <p>In HTML, form elements such as (input, textarea, and select) typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState().</p>
            <p>We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.</p>
        </section>
        
        <section id="Lifting_State_Up" class="main-section">
          <header>Lifting State Up</header>
          <p>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action.</p>
        </section>
        
        <section id="Thinking_React" class="main-section">
          <header>Thinking React</header>
          <p>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we’ll walk you through the thought process of building a searchable product data table using React.</p>
          <ul>
            <li>Start With A Mock</li>
            <li>Break The UI Into A Component Hierarchy</li>
            <li>Build A Static Version in React</li>
            <li>Identify The Minimal (but complete) Representation Of UI State</li>
            <li>Identify Where Your State Should Live</li>
            <li>Add Inverse Data Flow</li>
          </ul>
        </section>
        
      </main>
      
</body>
</html>